<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.5" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/uploads/apple-touch-icon-next.png?v=6.0.5">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-32x32.png?v=6.0.5">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-16x16.png?v=6.0.5">


  <link rel="mask-icon" href="/uploads/logo.svg?v=6.0.5" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.5',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Android, Life" />


<meta name="description" content="记录学习、生活">
<meta property="og:type" content="website">
<meta property="og:title" content="無名小子的杂货铺">
<meta property="og:url" content="http://whiskeyfei.github.io/page/4/index.html">
<meta property="og:site_name" content="無名小子的杂货铺">
<meta property="og:description" content="记录学习、生活">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="無名小子的杂货铺">
<meta name="twitter:description" content="记录学习、生活">






  <link rel="canonical" href="http://whiskeyfei.github.io/page/4/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>無名小子的杂货铺</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">無名小子的杂货铺</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">越努力越幸运</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
</li>

      

      
    </ul>
  

  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://whiskeyfei.github.io/2016/03/25/android/2016-11-06-rxjava-demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="無名">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/face.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="無名小子的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/25/android/2016-11-06-rxjava-demo/" itemprop="url">RxJava语法练习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-25T11:59:01+09:00">2016-03-25</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很早之前就听Rxjava 多么神奇，各种评论都有，说学习坡度高，难等等，于是亲自上手试试，说实话刚开始看到这些用法立马就蒙比了，和我们之前的方式不太一样，理解起来还是挺别扭的，之后找了一篇<a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a> 抛物线的，好好研究上几天，认真理解每个例子并自己动手敲出来，也就慢慢能体会到 rxjava 的好用之处了。</p>
<p>内容包含如下：<br> 如何获取，观察者模式，基本语法，操作符使用，线程控制使用</p>
<blockquote>
<p>注意：以下部分内容部分段落部分引用自<a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a>，如有冒犯之处，我会及时删除。</p>
</blockquote>
<h2 id="一、如何获取"><a href="#一、如何获取" class="headerlink" title="一、如何获取"></a>一、如何获取</h2><p><strong><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></strong><br><strong><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">RxAndroid</a></strong><br>在项目中引入依赖就好了，我这里用的不是最新版本</p>
<pre><code>compile &apos;io.reactivex:rxandroid:1.1.0&apos;
compile &apos;io.reactivex:rxjava:1.1.0&apos;
</code></pre><h2 id="二、观察者模式"><a href="#二、观察者模式" class="headerlink" title="二、观察者模式"></a>二、观察者模式</h2><p>这个模式基本上都听过，使用过的就可以直接略过了。</p>
<p>先说下设计模式中的观察者模式：</p>
<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern） 比如，当一个对象被修改时，则会自动通知它的依赖对象，观察者模式属于行为型模式。</p>
<p>使用在java中实现观察者模式需要用到java.util包中提供的Observable类和Observer接口，java已经给我们提供好类使用。</p>
<p>Observable可以查看java源码，下面是Observer接口：</p>
<pre><code>public interface Observer {
    void update(Observable observable, Object data);
}
</code></pre><p>举个简单例子：</p>
<p>古董被观察，观察者为people用来观察古董价钱波动<br>被观察者：</p>
<pre><code>public class Antique extends Observable {
    private float mPrice;// 价钱

    public Antique(float price) {
        this.mPrice = price;
    }

    public float getPrice() {
        return this.mPrice;
    }

    public void setPrice(float price) {
        super.setChanged();
        super.notifyObservers(price);// 价格被改变
        this.mPrice = price;
    }

    public String toString() {
        return &quot;古董价格为：&quot; + this.mPrice;
    }
}
</code></pre><p> 观察者实现Observer接口，重写update方法即可</p>
<pre><code>public class People implements Observer{

    private String name;

    public People(String name) {
        this.name = name;
    }

    @Override
    public void update(Observable observable, Object data) {
        Log.e(&quot;&quot;,&quot;People update() -&gt; update name:&quot;+ this.name + &quot;,price:&quot;+ ((Float)data).floatValue());
    }

}
</code></pre><p>   主函数调用</p>
<pre><code>Antique house = new Antique(1222f);
People p1 = new People(&quot;p1&quot;);
People p2 = new People(&quot;p2&quot;);
People p3 = new People(&quot;p3&quot;);
house.addObserver(p1);
house.addObserver(p2);
house.addObserver(p3);
Log.e(&quot;&quot;, house+&quot;&quot;); // 输出价格
house.setPrice(111f);
Log.e(&quot;&quot;, house+&quot;&quot;); // 输出价格
</code></pre><p>这样只要价格发生变化，就会通知所有订阅的人，也就实现了简单的观察者模式。</p>
<h4 id="RxJava-中的观察者模式"><a href="#RxJava-中的观察者模式" class="headerlink" title="RxJava 中的观察者模式"></a>RxJava 中的观察者模式</h4><p>观察者：Observer;<br><br>被观察者：Observable;<br><br>订阅：subscribe();<br></p>
<h5 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h5><p>Observer即为观察者，处理事件发生后逻辑，如古董例子，价格改变后，需要updae信息，不过 Rxjava 这里多了几种处理情况，onCompleted(),onError(),onNext(),具体用法看 dmeo 就可以了。</p>
<h5 id="被观察者"><a href="#被观察者" class="headerlink" title="被观察者"></a>被观察者</h5><p>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。可以使用create()、just(T…)、from(T[])或from(Iterable&lt;? extends T&gt;)来创建一个 Observable ，并为它定义事件触发规则。</p>
<h5 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h5><p>创建了Observable和Observer之后，再用subscribe()方法将它们联结起来。</p>
<h2 id="三、基本语法"><a href="#三、基本语法" class="headerlink" title="三、基本语法"></a>三、基本语法</h2><p>1、打印 Hello World</p>
<pre><code>Observable.create(new Observable.OnSubscribe&lt;String&gt;() {

     @Override
     public void call(Subscriber&lt;? super String&gt; subscriber) {
         subscriber.onNext(&quot;Hello World&quot;);
         subscriber.onCompleted();
     }
 }).subscribe(new Observer&lt;String&gt;() {
     @Override
     public void onCompleted() {
         System.out.println(&quot;onCompleted:&quot;);
     }

     @Override
     public void onError(Throwable e) {
         System.out.println(&quot;onError e:&quot;+e);
     }

     @Override
     public void onNext(String s) {
         System.out.println(&quot;onNext s:&quot;+s);
     }
 });

//还可以这么写

 Observable.just(&quot;hello World&quot;).subscribe(new Action1&lt;String&gt;() {
     @Override
     public void call(String s) {
         System.out.println(&quot;call s:&quot;+s);
     }
 });
</code></pre><p>2、将字符串数组 names 中的所有字符串依次打印出来</p>
<pre><code> String[] names = {&quot;111&quot;, &quot;222&quot;, &quot;333&quot;};
 Observable.from(names).subscribe(new Action1&lt;String&gt;() {
     @Override
     public void call(String name) {
         System.out.println(&quot;test1 name:&quot; + name);
     }
 });
// 输出
test1 name:111
test1 name:222
test1 name:333

另一种写法

 @Test
 public void test4(){
     //1:被观察者
     String [] names ={&quot;111&quot;,&quot;222&quot;,&quot;333&quot;};
     Observable observable = Observable.from(names);

     //2:观察者
     Action1 onNextAction = new Action1&lt;String&gt;() {
         @Override
         public void call(String s) {
             System.out.println(&quot;test4 call&quot;+s);
         }
     };

     Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() {
         @Override
         public void call(Throwable e) {
             System.out.println(&quot;test4 call e:&quot;+e);
       }
     };

     Action0 onCompletedAction = new Action0() {
         @Override
         public void call() {
             System.out.println(&quot;test4 call onCompletedAction&quot;);
         }
     };
     //3:订阅:被观察者被观察者订阅
     observable.subscribe(onNextAction, onErrorAction, onCompletedAction);
 }
</code></pre><p>3、just 将传入的参数依次打印</p>
<pre><code>@Test
public void test2(){
    Observable.just(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;).subscribe(new Observer&lt;String&gt;() {
        @Override
        public void onCompleted() {
            System.out.println(&quot;test2 onCompleted&quot;);
        }

        @Override
        public void onError(Throwable e) {
            System.out.println(&quot;test2 e:&quot;+e);
        }

        @Override
        public void onNext(String s) {
            System.out.println(&quot;onNext:&quot;+s);
        }
    });
}
  //    onNext:1
 //    onNext:2
//    onNext:3
//    test2 onCompleted
</code></pre><p>4、 循环输出list</p>
<pre><code>@Test
public void test5(){
    Observable.from(Data.getCats().get(0).getlist()).subscribe(new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            System.out.println(&quot;test5 call :&quot;+s);
        }
    });
}

//    test5 call :list:0
//    test5 call :list:1
//    test5 call :list:2
//    test5 call :list:3
//    test5 call :list:4
//    test5 call :list:5
//    test5 call :list:6
//    test5 call :list:7
//    test5 call :list:8
//    test5 call :list:9
</code></pre><h2 id="四、操作符使用"><a href="#四、操作符使用" class="headerlink" title="四、操作符使用"></a>四、操作符使用</h2><p>1、map：遍历list中的name，使用map操作符来获取list中的单项</p>
<pre><code>@Test
public void test7(){
    Observable.from(Data.getCats(10)).map(new Func1&lt;Cat, String&gt;() {

      @Override
      public String call(Cat cat) {
          return cat.toCat();//获取cat name
      }
  }).subscribe(new Observer&lt;String&gt;() {
      @Override
      public void onCompleted() {
          System.out.println(&quot;test7 onCompleted:&quot;);
      }

      @Override
      public void onError(Throwable e) {
          System.out.println(&quot;test7 onCompleted e:&quot;+e);
      }

      @Override
      public void onNext(String s) {
          System.out.println(&quot;test7 onNext :&quot;+s);
      }
  });
}

//  test7 onNext :0
//  test7 onNext :1
//  test7 onNext :2
//  test7 onNext :3
//  test7 onNext :4
//  test7 onNext :5
//  test7 onNext :6
//  test7 onNext :7
//  test7 onNext :8
//  test7 onNext :9
//  test7 onCompleted:
</code></pre><p>2、flatMap：<br>  循环List<cat> -&gt; cat里面的list -&gt; list 中的 String</cat></p>
<pre><code> @Test
 public void test8() {
     //循环List&lt;Cat&gt; -&gt; cat里面的list -&gt; list 中的 String
     Observable
             .from(Data.getCats())
             .flatMap(new Func1&lt;Cat, Observable&lt;String&gt;&gt;() {
                 @Override
                 public Observable&lt;String&gt; call(Cat cat) {
                     System.out.println(&quot;test8 call #########&quot; + cat.toCat());
                     return Observable.from(cat.getlist());
                 }
             })
             .subscribe(new Action1&lt;String&gt;() {
                 @Override
                 public void call(String s) {
                     System.out.println(&quot;test8 call :&quot; + s);
                 }
     });
 }
//  部分log
//  test8 call #########Cat0
//  test8 call :0:list
//  test8 call :1:list
//  test8 call :2:list
//  test8 call :3:list
//  test8 call :4:list
//  test8 call #########Cat1
//  test8 call :0:list
//  test8 call :1:list
//  test8 call :2:list
//  test8 call :3:list
//  test8 call :4:list
//  test8 call #########Cat2
//  test8 call :0:list
//  test8 call :1:list
//  test8 call :2:list
//  test8 call :3:list
//  test8 call :4:list
</code></pre><h2 id="五、线程控制使用"><a href="#五、线程控制使用" class="headerlink" title="五、线程控制使用"></a>五、线程控制使用</h2><p>以上的测试例子中，事件的发起和消费都是在同一个线程执行的，等同于 RxJava 是同步执行(学习使用)，但是，观察者模式本身就是等触发后才通知其他订阅者，所以来了解下 RxJava 如何使用线程的。</p>
<p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()<br>，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。</p>
<p>  1) Scheduler 的 API (一)</p>
<p> 在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景：</p>
<p>  1、Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p>
<p>  2、Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p>
<p>  3、Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>
<p>  4、 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>
<p>  5、另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</p>
<p>  有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 <em> subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 </em> observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。</p>
<pre><code>ImageView显示图片：


       Observable.just(R.drawable.ic_launcher).map(new Func1&lt;Integer, Drawable&gt;() {

        @Override
        public Drawable call(Integer integer) {
            return getResources().getDrawable(integer);
        }
        }).subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
            .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
        .subscribe(new Observer&lt;Drawable&gt;() {
        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {
            Toast.makeText(MainActivity.this, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();
        }

        @Override
        public void onNext(Drawable drawable) {
            mImageView.setImageDrawable(drawable);
        }
        });
</code></pre><h5 id="多次切换线程"><a href="#多次切换线程" class="headerlink" title="多次切换线程"></a>多次切换线程</h5><pre><code>Observable.just(1, 2, 3, 4)
.subscribeOn(Schedulers.newThread()) // 指定 subscribe() 发生在 IO 线程
.observeOn(Schedulers.io()) // 指定在IO线程处理
.map(new Func1&lt;Integer, Integer&gt;() {

    @Override
    public Integer call(Integer integer) {
        return integer+1;
    }
})
.observeOn(AndroidSchedulers.mainThread())// 指定 Subscriber 的回调发生在主线程
.subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer number) {
        Log.d(TAG, &quot;number:&quot; + number);
    }
});
</code></pre><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><ul>
<li><a href="https://github.com/whiskeyfei/Node-for-Android/blob/master/Design/%E8%A7%82%E5%AF%9F%E8%80%85.md" target="_blank" rel="noopener">观察者</a></li>
<li><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></li>
</ul>
<h2 id="七、小结"><a href="#七、小结" class="headerlink" title="七、小结"></a>七、小结</h2><p>代码已上传 <a href="https://github.com/whiskeyfei/WFAndroidDemo/tree/master/WFRxJavaDemo" target="_blank" rel="noopener">WFRxJavaDemo</a>，欢迎指正。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://whiskeyfei.github.io/2016/03/25/android/2016-3-26-node-rxjava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="無名">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/face.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="無名小子的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/25/android/2016-3-26-node-rxjava/" itemprop="url">RxJava 初学和在 Android 项目中的简单应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-25T11:59:01+09:00">2016-03-25</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间关于 RxJava 的内容铺天盖地，作为一个 Android 开发，总有一种必须要学一学的感觉，今天来说说 RxJava，当然了只是简单应用，<br>自己也没有那么深入研究，不过可以在使用过程中慢慢去了解 RxJava 的机制。本文例子有一些来源于网上，也是一步一步跟着看下来，如有引用不当<br>请及时告知，我及时更改。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>这里需要说一下观察者模式，RxJava 是扩展的观察者模式，先要了解下观察者模式，我在 java 基础中有纪录，可以去看<a href="!--￼0--&gt;/日常/2015/11/26/java-base.html">设计模式－观察者模式</a>，自己敲一个 Demo 就行了，最常见的 Android 中Button绑定点击监听事件，其实不了解观察者模式也能理解这种点击监听事件处理，<br>觉得用的非常合理，我有一个 Button ，想点击时跳转另一个页面，就需要给 Button 绑定一个 Listener ，跳转的逻辑在监听里面做。<br>按照观察者模式思考的话，Button ＝ 被观察者，Listener 是观察者，二者绑定在一起，就形成了 Button 被点击，Listener 被执行。完事。</p>
<h2 id="RxJava-的观察者模式"><a href="#RxJava-的观察者模式" class="headerlink" title="RxJava 的观察者模式"></a>RxJava 的观察者模式</h2><p>RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。</p>
<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。</p>
<p>onCompleted(): 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。<br>onError(): 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。<br>在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</p>
<p>以上完全摘自<a href="http://gank.io/post/560e15be2dca930e00da1083#toc_1" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a>,写的特别好，自己看了不少20遍。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>刚开始看 <a href="http://gank.io/post/560e15be2dca930e00da1083#toc_1" target="_blank" rel="noopener">Android 开发者的 RxJava 详解</a>的时候有些确实不太明白，然后自己又跟着<a href="http://www.devtf.cn/?p=323" target="_blank" rel="noopener">NotRxJava懒人专用指南</a> 敲了所有的代码，然后才渐渐的理解 RxJava 原来是想达到这样的效果，然后在开始练习 RxJava 相关的 case 就很容易理解了。</p>
<p>1、NotRxJava</p>
<p>这例子是跟着<a href="http://www.devtf.cn/?p=323" target="_blank" rel="noopener">NotRxJava懒人专用指南</a> 完成的例子，这里简单说一说。</p>
<p>有个需求是这样描述的:从网络获取 Cat 列表数据，根本某个条件找出相应的 Cat；<br>再没有用过 RxJava 时，我们可能就会一步一步的进行操作，先获取数据 -&gt; 解析数据 -&gt; 循环匹配。看似非常完美，然后某一天又增加了一天过滤条件，就要在原来的基础上<br>修改，然后。。然后。。。改。。改。。，我们肯定不想过这样的日子。</p>
<p>下面用 <a href="http://www.devtf.cn/?p=323" target="_blank" rel="noopener">NotRxJava懒人专用指南</a> 来简单实现这样一个功能，在使用时简化了很多，传入条件，直接返回结果，不需要了解内部的实现，符合最简。</p>
<p>调用方式</p>
<pre><code>CatsHelper4 catsHelper4 = new CatsHelper4();
      catsHelper4.saveTheCutestCat(Constants.BAIDU).start(new Callback&lt;String&gt;() {
          @Override
          public void onResult(String result) {
              Log.e(TAG,&quot;catsHelperTest4 result:&quot;+result);
          }

          @Override
          public void onError(Exception e) {
              Log.e(TAG,&quot;catsHelperTest4 e:&quot;+e);
          }
      });

  public class CatsHelper4 {
      ApiWrapper3 apiWrapper = new ApiWrapper3();

      public AsyncJob&lt;String&gt; saveTheCutestCat(final String query) {
         final AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query);
  //        这 16 行代码只有一行是对我们有用（对于逻辑来说）的操作：
  //        findCutest(result)

          final AsyncJob&lt;Cat&gt; cutestCatAsyncJob = new AsyncJob&lt;Cat&gt;(){

              @Override
              public void start(final Callback&lt;Cat&gt; callback) {
                  catsListAsyncJob.start(new Callback&lt;List&lt;Cat&gt;&gt;() {
                      @Override
                      public void onResult(List&lt;Cat&gt; result) {
                          callback.onResult(findCutest(result));
                      }

                      @Override
                      public void onError(Exception e) {
                          callback.onError(e);
                      }
                  });
              }
          };

          AsyncJob&lt;String&gt; stringAsyncJob = new AsyncJob&lt;String&gt;() {
              @Override
              public void start(final Callback&lt;String&gt; cutestCatCallback) {
                  cutestCatAsyncJob.start(new Callback&lt;Cat&gt;() {
                      @Override
                      public void onResult(Cat result) {
                          apiWrapper.store(result).start(new Callback&lt;String&gt;() {
                              @Override
                              public void onResult(String result) {
                                  cutestCatCallback.onResult(result);
                              }

                              @Override
                              public void onError(Exception e) {
                                  cutestCatCallback.onError(e);
                              }
                          });
                      }

                      @Override
                      public void onError(Exception e) {
                          cutestCatCallback.onError(e);
                      }
                  });
              }
          };

          return stringAsyncJob;
      }

      private Cat findCutest(List&lt;Cat&gt; cats) {
          return cats.get(0);
      }
  }            

  public class ApiWrapper3 {
      Api api = new ApiTest();

      public AsyncJob&lt;List&lt;Cat&gt;&gt; queryCats(final String query) {
          return new AsyncJob&lt;List&lt;Cat&gt;&gt;() {
              @Override
              public void start(final Callback&lt;List&lt;Cat&gt;&gt; catsCallback) {
                  api.queryCats(query, new Api.CatsQueryCallback() {

                      @Override
                      public void onCatListReceived(List&lt;Cat&gt; cats) {
                          catsCallback.onResult(cats);
                      }

                      @Override
                      public void onError(Exception e) {
                          catsCallback.onError(e);
                      }
                  });
              }
          };
      }

      public AsyncJob&lt;String&gt; store(final Cat cat) {
          return new AsyncJob&lt;String&gt;() {
              @Override
              public void start(final Callback&lt;String&gt; callback) {
                  api.store(cat, new Api.StoreCallback() {
                      @Override
                      public void onCatStored(String s) {
                          callback.onResult(s);
                      }

                      @Override
                      public void onStoreFailed(Exception e) {
                          callback.onError(e);
                      }
                  });
              }
          };
      }
  }
</code></pre><p>首先调用非常简单，生成一个对象 CatsHelper4 ，使用 saveTheCutestCat 方法，传入一个 url 地址，成功则返回 Cat result，失败则返回 Exception 信息；</p>
<p>saveTheCutestCat 方法会触发queryCats(query) 方法，并 new 一个 AsyncJob<cat> 对象，queryCats 是一个异步操作，真正起获取网络请求的是在 ApiTest 中，它实现了Api接口，这部分先不考虑，这部分可以单独拿出来，我们就当数据已经获取了，并且赋值给了 catsListAsyncJob 变量，这时候 saveTheCutestCat 方法中返回一个 AsyncJob<string> 对象，其实就是结果，但是这个结果触发是在获取数据之后，由catsHelper4.saveTheCutestCat(Constants.BAIDU).start() ,start 方法开始，根据 url<br>stringAsyncJob.start -&gt; cutestCatAsyncJob.start -&gt; apiWrapper.store -&gt; result，相当于是一个逆向操作，在写的时候是一步一步正向操作，而在调用的时候<br>需要直接拿结果，结果没有再向上获取上一个结果，形成一个闭环。</string></cat></p>
<p>这个例子可能看上去太过于麻烦，当时看的时候自己也觉得是，但是当你真正写了一遍以后，就会发现，我们平时编程就应该有这种思想，使用方式特别简单，接口抽象等等，这样<br>才能做好易于扩展。</p>
<p>但说回来，这就是一个类似于 Rxjava 的例子，可能远远不够，因为没有观察者模式，所以下面我们来练习使用 RxJava 的基本方法；</p>
<p>2、Rxjava 练习</p>
<p>练习使用创建Observable、快速创建 create from just等、map flatMap filter doOnNext 等函数使用</p>
<ul>
<li>map: 事件对象的直接变换,非常灵活和实用，例子中有很多，string -&gt; int;</li>
<li>flatMap: 事件操作符<br>  flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象，但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。</li>
<li>filter:用于过滤等。</li>
<li>take:获取个数。</li>
<li><p>doOnNext:允许我们在每次输出一个元素之前做一些额外的事情</p>
<pre><code>//将字符串数组 names 中的所有字符串依次打印出来,并且支持不完整得回调

@Test
public void test1(){
    String [] names ={&quot;111&quot;,&quot;222&quot;,&quot;333&quot;};
    Observable.from(names).subscribe(new Action1&lt;String&gt;() {
        @Override
        public void call(String name) {
            System.out.println(&quot;test1 name:&quot;+name);
        }
    });
}

//just 将传入的参数依次打印
//    onNext:1
//    onNext:2
//    onNext:3
//    test2 onCompleted
@Test
public void test2(){
    Observable.just(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;).subscribe(new Observer&lt;String&gt;() {
        @Override
        public void onCompleted() {
            System.out.println(&quot;test2 onCompleted&quot;);
        }

        @Override
        public void onError(Throwable e) {
            System.out.println(&quot;test2 e:&quot;+e);
        }

        @Override
        public void onNext(String s) {
            System.out.println(&quot;onNext:&quot;+s);
        }
    });
}
</code></pre></li>
</ul>
<pre><code> //将字符串数组 names 中的所有字符串依次打印出来
    //    依次调用onNext(&quot;111&quot;)
    //    依次调用onNext(&quot;222&quot;)
    //    依次调用onNext(&quot;333&quot;)
    @Test
    public void test3(){
        String [] names ={&quot;111&quot;,&quot;222&quot;,&quot;333&quot;};
        Observable.from(names).subscribe(new Observer&lt;String&gt;() {
            @Override
            public void onCompleted() {
                System.out.println(&quot;test3 onCompleted&quot;);
            }

            @Override
            public void onError(Throwable e) {
                System.out.println(&quot;test3 e:&quot;+e);
            }

            @Override
            public void onNext(String s) {
                System.out.println(&quot;test3 onNext:&quot;+s);
            }
        });
    }


//将字符串数组 names 中的所有字符串依次打印出来
//    依次调用onNext(&quot;111&quot;)
//    依次调用onNext(&quot;222&quot;)
//    依次调用onNext(&quot;333&quot;)
@Test
public void test4(){
    //1:被观察者
    String [] names ={&quot;111&quot;,&quot;222&quot;,&quot;333&quot;};
    Observable observable = Observable.from(names);

    //2:观察者
    Action1 onNextAction = new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            System.out.println(&quot;test4 call&quot;+s);
        }
    };

    Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() {
        @Override
        public void call(Throwable e) {
            System.out.println(&quot;test4 call e:&quot;+e);
        }
    };


    Action0 onCompletedAction = new Action0() {
        @Override
        public void call() {
            System.out.println(&quot;test4 call onCompletedAction&quot;);
        }
    };
    //3:订阅:被观察者被观察者订阅
    observable.subscribe(onNextAction, onErrorAction, onCompletedAction);
}

//循环输出list
//    test5 call :list:0
//    test5 call :list:1
//    test5 call :list:2
//    test5 call :list:3
//    test5 call :list:4
//    test5 call :list:5
//    test5 call :list:6
//    test5 call :list:7
//    test5 call :list:8
//    test5 call :list:9
@Test
public void test5(){
    Observable.from(Data.getCats().get(0).getlist()).subscribe(new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            System.out.println(&quot;test5 call :&quot;+s);
        }
    });
}        


//cats -&gt; cat.list -&gt; s
//1:被观察者

//2:数据转换

//3:被观察者被观察者订阅

//4:观察者
@Test
public void test8(){
    Observable.from(Data.getCats()).flatMap(new Func1&lt;Cat, Observable&lt;String&gt;&gt;() {
        @Override
        public Observable&lt;String&gt; call(Cat cat) {
            return Observable.from(cat.getlist());
        }
    }).subscribe(new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            System.out.println(&quot;test8 call :&quot;+s);
        }
    });
}


//操作符 用来转换string

Observable.just(&quot;hello World&quot;).map(new Func1&lt;String, String&gt;() {

    @Override
    public String call(String s) {
        return s + &quot;:test&quot;;
    }
}).subscribe(new Observer&lt;String&gt;() {
    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
    }

    @Override
    public void onNext(String s) {
        System.out.println(&quot;onNext s:&quot;+s);
    }
});


//string -&gt; hashCode
Observable.just(&quot;Hello, world!&quot;).map(new Func1&lt;String, Integer&gt;() {

    @Override
    public Integer call(String s) {
        return s.hashCode();
    }
}).subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
    }

    @Override
    public void onNext(Integer integer) {
        System.out.println(&quot;onNext integer:&quot;+integer);
    }
});


//转换三次 string -&gt; int &gt; string &gt; int
Observable.just(&quot;Hello, world!&quot;).map(new Func1&lt;String, Integer&gt;() {

    @Override
    public Integer call(String s) {
        return s.hashCode();
    }
}).map(new Func1&lt;Integer, String&gt;() {

    @Override
    public String call(Integer integer) {
        return Integer.toString(integer);
    }
}).subscribe(new Observer&lt;String&gt;() {
    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
    }

    @Override
    public void onNext(String s) {
        System.out.println(&quot;onNext s:&quot;+s);
    }
});


    @Test
public void ObserverList(){
    Observable.create(new Observable.OnSubscribe&lt;List&lt;String&gt;&gt;() {

        @Override
        public void call(Subscriber&lt;? super List&lt;String&gt;&gt; subscriber) {
            List&lt;String&gt; list = new ArrayList&lt;&gt;();
            for (int i = 0;i&lt;10;i++){
                list.add(i + &quot;--&quot;);
            }
            subscriber.onNext(list);
        }
    }).subscribe(new Observer&lt;List&lt;String&gt;&gt;() {
        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {

        }

        @Override
        public void onNext(List&lt;String&gt; strings) {
            System.out.println(&quot;flatMapTest onNext strings:&quot;+strings);
        }
    });
}

// list -&gt; string -&gt; 不为null -&gt; 获取5个
@Test
public void flatMapTest(){
    //flatMap操作符
    Observable.create(new Observable.OnSubscribe&lt;List&lt;String&gt;&gt;() {

        @Override
        public void call(Subscriber&lt;? super List&lt;String&gt;&gt; subscriber) {
            List&lt;String&gt; list = new ArrayList&lt;&gt;();
            for (int i = 0;i&lt;10;i++){
                list.add(i + &quot;--&quot;);
            }
            subscriber.onNext(list);
        }
    }).flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() {
        @Override
        public Observable&lt;String&gt; call(List&lt;String&gt; strings) {
            return Observable.from(strings);
        }
    }).filter(new Func1&lt;String, Boolean&gt;() {
        @Override
        public Boolean call(String s) {
            //滤掉null值
            return s != null;
        }
        //take只需要5个 获取的意思
    }).take(5).doOnNext(new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            //doOnNext()允许我们在每次输出一个元素之前做一些额外的事情
        }
    }).subscribe(new Observer&lt;String&gt;() {
        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {

        }

        @Override
        public void onNext(String s) {
            System.out.println(&quot;flatMapTest onNext s:&quot;+s);
        }
    });
}


@Test
public void subscriptionTest(){
    Subscription subscription = Observable.just(&quot;&quot;).subscribe(new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {

        }
    });
    subscription.isUnsubscribed();//检查是否已经取消订阅
    subscription.unsubscribe();//停止整个链
}   
</code></pre><h2 id="Android使用"><a href="#Android使用" class="headerlink" title="Android使用"></a>Android使用</h2><p>在 Android 中，我们就要注意调度器 Scheduler 的使用时机，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。<br>比如需要在线程中使用，访问网络，又要在UI主线程中执行结果，等等其他一些情况。</p>
<ul>
<li>subscribeOn(): 指定 subscribe 所发生的线程;</li>
<li>observeOn(): 指定 Subscriber 所运行在的线程;</li>
</ul>
<p>目前开发我使用 Schedulers.io()指定发生的线程，使用 AndroidSchedulers.mainThread()在 Android 主线程运行结果，这个只是在<br>当前例子中的用法，其他的查看底部的推荐内容，很详细。</p>
<p>我这里会绘制一个文件名称列表，没有的话先会创建文件，然后在绘制 ListView 上。</p>
<pre><code>private void readFile() {
    Observable.just(mPath).map(new Func1&lt;String, File[]&gt;() {

        @Override
        public File[] call(String path) {
            File file = new File(path);
            return file.listFiles();
        }
    }).map(new Func1&lt;File[], List&lt;String&gt;&gt;() {

        @Override
        public List&lt;String&gt; call(File[] files) {
            return Data.changeList(files);
        }
    }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer&lt;List&lt;String&gt;&gt;() {
        @Override
        public void onCompleted() {
            Log.e(TAG,&quot;onCompleted&quot;);
        }

        @Override
        public void onError(Throwable e) {
            Log.e(TAG,&quot;onError e:&quot; + e);
        }

        @Override
        public void onNext(List&lt;String&gt; list) {
            Log.e(TAG,&quot;onNext list:&quot; + list);
            mAdapter.setDate(list);
        }
    });
}
</code></pre><p>这里没有贴出在 APP 包名下创建文件的过程，只有读写的过程，首先是根据路径获得 file list，然后转换成List<string> 列表，指定在 io 线程启动，在<br>UI 主线程执行结果，刷新UI。我一般在使用 MVP 开发的时候，将 create Observable 这个过程放到 M 层来做，subscribeOn 放到 P 层来做，这样直接将结果回调给 View 层。    </string></p>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><ul>
<li><a href="http://gank.io/post/560e15be2dca930e00da1083#toc_1" target="_blank" rel="noopener">Android 开发者的 RxJava 详解</a></li>
<li><a href="http://www.devtf.cn/?p=323" target="_blank" rel="noopener">NotRxJava懒人专用指南</a></li>
<li><a href="https://github.com/whiskeyfei/WFAndroidDemo/tree/master/WFRxJavaDemo" target="_blank" rel="noopener">WFRxJavaDemo</a> Demo例子都在里面</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://whiskeyfei.github.io/2016/03/24/tech/2016-3-24-node-string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="無名">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/face.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="無名小子的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/24/tech/2016-3-24-node-string/" itemprop="url">String、StringBuffer、StringBuilder 纪录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-24T12:26:35+09:00">2016-03-24</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/日常/" itemprop="url" rel="index"><span itemprop="name">日常</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>抽空总结了下 java 字符串相关知识点，平常使用最多的就是 String 类了，用于处理一些简单的字符串问题，比如：常量；当遇到相对复杂一些并且需要频繁拼接字符串时，就需要用到StringBuffer和StringBuilder了，以下都是自己平时的纪录方便查漏补缺，有些也摘自网上，这里做下整理，如果有侵犯您的内容，请通知我会及时修改。</p>
<h2 id="大概情况："><a href="#大概情况：" class="headerlink" title="大概情况："></a>大概情况：</h2><p>String 字符串常量</p>
<p>StringBuffer 字符串变量（线程安全）</p>
<p>StringBuilder 字符串变量（非线程安全）</p>
<h2 id="单个理解："><a href="#单个理解：" class="headerlink" title="单个理解："></a>单个理解：</h2><p>String:是不可改变的量，创建后不能在修改,多用于不经常改变的的常量，无频繁拼接操作的场景；</p>
<p>StringBuffer:</p>
<pre><code>* A modifiable {@link CharSequence sequence of characters} for use in creating

* strings, where all accesses are synchronized. This class has mostly been replaced

* by {@link StringBuilder} because this synchronization is rarely useful. This

* class is mainly used to interact with legacy APIs that expose it.
</code></pre><p>StringBuilder:</p>
<pre><code>* A modifiable {@link CharSequence sequence of characters} for use in creating

* strings. This class is intended as a direct replacement of

* {@link StringBuffer} for non-concurrent use; unlike {@code StringBuffer} this

* class is not synchronized.
</code></pre><p>看下两个的源码解释就很清楚了，两者都是可变字符串序列，基本用法和 String 一样，不同点就是 StringBuffer 是线程安全的，StringBuilder 是线程不安全的，其实就是同步和不同步的问题；</p>
<h3 id="插播一条如何理解线程安全和线程不安全。。"><a href="#插播一条如何理解线程安全和线程不安全。。" class="headerlink" title="插播一条如何理解线程安全和线程不安全。。"></a>插播一条如何理解线程安全和线程不安全。。</h3><p>比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成：</p>
<p>1、在Items[Size] 的位置存放此元素；<br><br>2、增大 Size 的值；</p>
<p>在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；<br>而如果是在多线程情况下，比如有两个线程，线程 A 先将元素1存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。<br>线程B向此 ArrayList 添加元素2，因为此时 Size 仍然等于 0 （注意，我们假设的是添加一个元素是要两个步骤，而线程A仅仅完成了步骤1），<br>所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值，结果Size都等于1。<br>那好，我们来看看 ArrayList 的情况，期望的元素应该有2个，而 实际元素是在0位置，造成丢失元素，故Size 等于 1。<br>这就是“线程不安全”了。<br>还让我联想到另外一个例子，就是银行存取钱过程，这里就不展开说了，大家想想对比一下实际情况就能明白。</p>
<p>赶紧扯回来String。。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>1、String</p>
<pre><code>String a = &quot;abc&quot;;
a.replace(&apos;a&apos;, &apos;d&apos;);
System.out.println(a);//结果abc，不改变
</code></pre><p>2、StringBuffer</p>
<p>StringBuffer对象的初始化不像String类的初始化一样，Java提供的有特殊的语法，而通常情况下一般使用构造方法进行初始化</p>
<pre><code>StringBuffer sb = new StringBuffer(&quot;123&quot;);
sb.append(&quot;123&quot;).append(&quot;123&quot;);
</code></pre><p>注：在使用 StringBuffer 的时候，需要注意不能想用 String 它一样使用</p>
<pre><code>StringBuffer result = null;  
结果警告：Null pointer access: The variable result can only be null at this location
</code></pre><p>3、StringBuilder</p>
<p>使用方式和 StringBuffer 一样，还有一些基本操作字符串函数的方法，append、deleteCharAt、insert等等，这里就不一一介绍如何使用了，看名字就知道怎么用了。</p>
<p>注：StringBuffer和String属于不同的类型，也不能直接进行强制类型转换，下面的代码都是错误的：</p>
<pre><code>StringBuffer s = “abc”;               //赋值类型不匹配
StringBuffer s = (StringBuffer)”abc”;    //不存在继承关系，无法进行强转
</code></pre><p>StringBuffer对象和String对象之间的互转的代码如下：</p>
<pre><code>String s = “abc”;
StringBuffer sb1 = new StringBuffer(“123”);
StringBuffer sb2 = new StringBuffer(s);   //String转换为StringBuffer
String s1 = sb1.toString();              //StringBuffer转换为String
</code></pre><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String是不可变的对象, 因此每次对 String 类型进行改变的时候都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，会影响运行速度。</p>
<p>而 StringBuffer 类则结果就不一样，每次结果都会对 StringBuffer 对象本身进行操作，而不生成新的对象，再改变对象引用。<br>所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下，<br>String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，<br>而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>
<pre><code>String S1 = “This is only a” + “ simple” + “ test”;
StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);
你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。
其实这是 JVM 的一个把戏，在 JVM 眼里，这个
String S1 = “This is only a” + “ simple” + “test”; 其实就是：
String S1 = “This is only a simple test”;
所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：
String S2 = “This is only a”;
String S3 = “ simple”;
String S4 = “ test”;
String S1 = S2 +S3 + S4;

这时候 JVM 会规规矩矩的按照原来的方式去做
当然这种简单的方式我们也不会去选择 StringBuffer 来拼接了，用 String 就好了。
</code></pre><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>在大部分情况下 StringBuffer &gt; String</p>
<p>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。<br>虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p>
<p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。<br>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p>
<p>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。</p>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>在大部分情况下 StringBuilder &gt; StringBuffer</p>
<p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。<br>该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。<br>如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快，两者的方法基本相同。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://github.thinkingbar.com/how-to-use-string/" target="_blank" rel="noopener">浅谈 Java 字符串</a></li>
<li><a href="http://www.cnblogs.com/zwq194/archive/2012/06/26/2563567.html" target="_blank" rel="noopener">什么是线程安全和线程不安全</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://whiskeyfei.github.io/2016/03/09/tech/2016-3-8-gson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="無名">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/face.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="無名小子的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/09/tech/2016-3-8-gson/" itemprop="url">Gson库项目使用 - @SerializedName</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-09T15:11:17+09:00">2016-03-09</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/日常/" itemprop="url" rel="index"><span itemprop="name">日常</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          Gson日常使用
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/03/09/tech/2016-3-8-gson/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://whiskeyfei.github.io/2016/02/26/android/2015-11-10-github-project-collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="無名">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/face.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="無名小子的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/26/android/2015-11-10-github-project-collection/" itemprop="url">Github日常项目收集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-26T10:21:51+09:00">2016-02-26</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/日常/" itemprop="url" rel="index"><span itemprop="name">日常</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Github日常项目收集整理，快速查看</p>
<p>1、<a href="https://github.com/lgvalle/Material-Animations" target="_blank" rel="noopener">Material-Animations</a>－Android过渡动画解释和例子.<br><br>2、<a href="https://github.com/Juude/awesome-android-performance" target="_blank" rel="noopener">awesome-android-performance</a>Android性能优化视频，文档以及工具<br><br>3、<a href="https://github.com/ZhaoKaiQiang/ParticleLayout" target="_blank" rel="noopener">ParticleLayout</a>左滑粒子效果<br><br>4、<a href="https://github.com/k0shk0sh/Fast-Access-Floating-Toolbox-" target="_blank" rel="noopener">Fast-Access-Floating-Toolbox</a>流动的工具箱，快速开发<br><br>5、<a href="源代码头安卓开发的媒体">HeadFirstAndroid</a><br><br>6、<a href="https://github.com/sasakicks/DraggableFlipView" target="_blank" rel="noopener">DraggableFlipView</a>一个摇曳旋转的效果<br><br>7、<a href="https://github.com/fengjundev/Android-Skin-Loader" target="_blank" rel="noopener">Android-Skin-Loader</a>一个通过动态加载本地皮肤包进行换肤的皮肤框架<br><br>7、<a href="https://github.com/plattysoft/Leonids" target="_blank" rel="noopener">Leonids</a>粒子效果<br><br>8、<a href="https://github.com/android-cjj/Android-MaterialRefreshLayout" target="_blank" rel="noopener">Android-MaterialRefreshLayout</a>一个强大的刷新控件<br><br>9、<a href="https://github.com/dengshiwei/SogoLoading" target="_blank" rel="noopener">SogoLoading</a>搜狗的loading<br><br>10、<a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="noopener">AndResGuard</a>Android混淆工具<br><br>11、<a href="https://github.com/H07000223/FlycoPageIndicator" target="_blank" rel="noopener">FlycoPageIndicator</a> Viewpager 幻灯效果切换<br><br>12、<a href="https://github.com/xmuSistone/android-vertical-slide-view" target="_blank" rel="noopener">android-vertical-slide-view</a>仿照淘宝和聚美优品，在商品详情页，向上拖动时，可以加载下一页<br><br>13、<a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="noopener">androidmvp-Android中的MVP</a>简单得AndroidMVP实例,<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0227/2503.html" target="_blank" rel="noopener">更好理解－Android中的MVP</a><br><br>14、<a href="https://github.com/facebook/fresco" target="_blank" rel="noopener">fresco</a>Fresco图片加载使用<br><br>15、<a href="https://github.com/CtripMobile/DynamicAPK" target="_blank" rel="noopener">DynamicAPK</a>携程实现Android多apk插件化和动态加载，支持资源分包<br><br>16、<a href="https://github.com/ragnraok/StaticLayoutView" target="_blank" rel="noopener">TextView预渲染研究</a><br><br>17、<a href="https://github.com/baoyongzhang/Treasure" target="_blank" rel="noopener">SharePreferences包装库</a><br><br>18、<a href="https://github.com/ZhaoKaiQiang/KLog" target="_blank" rel="noopener">KLog</a>LogCat方便打印log<br><br>19、<a href="https://github.com/frankiesardo/LinearListView" target="_blank" rel="noopener">LinearListView</a>LinearListView快速滑动<br><br>20、<a href="https://github.com/jobbole/awesome-java-cn" target="_blank" rel="noopener">awesome-java-cn</a>Java资源大全中文版<br><br>21、<a href="https://github.com/lgvalle/Material-Animations.git" target="_blank" rel="noopener">Material-Animations</a>Android过渡动画解释和例子。<br><br>22、<a href="https://github.com/daimajia/AnimationEasingFunctions" target="_blank" rel="noopener">AnimationEasingFunctions</a>Android Animation Easing Functions. Let’s make animation more real!<br><br>23、<a href="https://github.com/z56402344/BaseAnimation.git" target="_blank" rel="noopener">BaseAnimation</a>动画合集<br><br>24、 <a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">leakcanary</a>内存检测<br><br>25、<a href="https://github.com/frankiesardo/LinearListView" target="_blank" rel="noopener">LinearListView</a>LinearListView快速滑动<br><br>26、<a href="https://github.com/jobbole/awesome-java-cn" target="_blank" rel="noopener">awesome-java-cn</a>Java资源大全中文版<br><br>27、<a href="https://github.com/ogaclejapan/SmartTabLayout" target="_blank" rel="noopener">SmartTabLayout</a>快速切换tab<br>28、<a href="https://github.com/corerzhang/LabelView" target="_blank" rel="noopener">LabelView</a><br>29、<a href="https://github.com/futurice/android-best-practices/blob/master/translations/Chinese/README.cn.md" target="_blank" rel="noopener">android-best-practices</a>Android 开发最佳实践,记录一些规范等<br>30、<a href="https://github.com/hongyangAndroid/AndroidAutoLayout" target="_blank" rel="noopener">AndroidAutoLayout</a>Android屏幕适配方案，直接填写设计图上的像素尺寸即可完成适配，最大限度解决适配问题<br>31、<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a><br>32、<a href="https://github.com/chenupt/SpringIndicator" target="_blank" rel="noopener">SpringIndicator水滴效果viewpager</a><br><br>33、<a href="https://android.googlesource.com/platform/frameworks/volley/" target="_blank" rel="noopener">volley官方源码</a><br><br>34、<a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="noopener">android-volley非官方</a><br><br>35、<a href="https://github.com/bboyfeiyu/android-tech-frontier/tree/master/androidweekly/%E4%B8%80%E7%A7%8D%E5%9C%A8android%E4%B8%AD%E5%AE%9E%E7%8E%B0MVP%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B0%E6%80%9D%E8%B7%AF" target="_blank" rel="noopener">一种在android中实现MVP模式的新思路</a><br><br>36、<a href="https://github.com/qibin0506/MVPro" target="_blank" rel="noopener">MVPro</a><br><br>37、<a href="https://github.com/yesidlazaro/BadgedImageview" target="_blank" rel="noopener">BadgedImageview</a>10 条提升 Android 性能的建议<br><br>38、<a href="https://github.com/DavidWangTM/DWCinemaAnimation-Android" target="_blank" rel="noopener">DWCinemaAnimation-Android</a><br><br>39、<a href="https://github.com/wangdan/AisenWeiBo.git" target="_blank" rel="noopener">Aisen微博-新浪微博的第三方客户端</a>，非常适合独立开发者学习<br><br>40、<a href="https://github.com/spongebobrf/BookdashAndroidApp" target="_blank" rel="noopener">BookdashAndroidApp</a><br><br>41、<a href="https://github.com/VerbalExpressions/JavaVerbalExpressions" target="_blank" rel="noopener">JavaVerbalExpressions</a>口语化正则表达式<br><br>42、<a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="noopener">CircleImageView</a>圆形imageview<br><br>43、 <a href="https://github.com/TheFinestArtist/FinestWebView-Android" target="_blank" rel="noopener">FinestWebView-Android</a><br><br>44、<a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh" target="_blank" rel="noopener">android-Ultra-Pull-To-Refresh</a>秋百万<br><br>45、<a href="http://www.jayfeng.com/2015/12/29/APK%E7%98%A6%E8%BA%AB%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">APK瘦身实践</a> 总结非常好<br><br>46、<a href="https://github.com/glomadrian/loading-balls" target="_blank" rel="noopener">loading-balls</a>loading<br><br>47、<a href="https://github.com/dongjunkun/DropDownMenu" target="_blank" rel="noopener">一个实用的多条件筛选菜单</a><br></p>
<h3 id="–未完待续，如果有丢失链接得请告知，谢谢！"><a href="#–未完待续，如果有丢失链接得请告知，谢谢！" class="headerlink" title="–未完待续，如果有丢失链接得请告知，谢谢！"></a>–未完待续，如果有丢失链接得请告知，谢谢！</h3>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://whiskeyfei.github.io/2015/12/28/book/2016-3-22-book1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="無名">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/face.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="無名小子的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/28/book/2016-3-22-book1/" itemprop="url">《突然就走到了西藏》读书笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-28T21:55:26+09:00">2015-12-28</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书/" itemprop="url" rel="index"><span itemprop="name">读书</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>突然就走到了西藏 - 陈坤<br>无意中在微信阅读上读到了陈坤的《突然就走到了西藏》，陈坤－众所周知著名影视明星，大咖，偶然看到过行走的力量和海报，也偶然看到<br>陈坤开讲了。还记得金粉世家里面的金少爷，也就记得这个了，写到这里的时候，以前小时候的画面又浮现在了眼前，一家人围着电视，有时候也感动的<br>稀里哗啦，桥段简直太帅了，现在就记得一些片段了，回过神来，很早就想着自己没事的读读书，提升一下，总是心太浮躁，静不下来看不进去，<br>这不是自己工作以后读的第一本书，是第一个写读后感的书。写的像流水账，凑活着看，没准以后看了，还能乐呵乐呵，好吧，该进入主题了，总结了几个词：<br>迷茫、自省、成长、升华；</p>
<p>首先文章写的很平，没有那么晦涩难懂，花上一下午的时间就能读完，我读完最大的收获是给了我一些启示和正能量的东西，我相信大家读也是这样的，其实<br>有感受到一些就足够了，没有白读，我不去评论他写的是好是坏，这不重要，重要的是我们自己。</p>
<p>下面是一些在阅读当中比较有共鸣的地方，在这里拿出来，在细细品一品，对于这个时刻都在被遗忘的世界，有些记忆是值得怀念和书写的，我讲从这里开始。</p>
<h4>“别人眼中的什么样，并不重要，重要的是你自己想成为什么样，或者更确切地说，你想达成什么样”</h4>

<p>这段话引用文中的第二章，这句话在不同的时期有着不同的感受，我们都希望成为一个成功的人，外表光鲜亮丽，众人羡慕，可是又有多少人成为了那个想<br>成为的人，大部分都默默的过着自己的生活，有一天，问自己，你想自己成为什么人？或者成为一个别人眼里的什么人？很多时候，我都知道自己有多少能力，<br>能做多大的事情，可以并不会放弃努力向上。大学时候，有过迷茫，有过失意、也有过得意等等状态，但是有一个目标从来没有变过，那就是毕业去北京，这个<br>想法从选了专业，开始读大学就已经种下了，当时的想法很简单:”毕业不能回家，不能回家，得混出个样“，我想不只我这么想过，很多人都会有这样的想法，例如：回家不知道干什么，回家无聊，回家不自由，等等。</p>
<p>所以，那会虽然没有想过自己成为一个成功的人，但也想过成为一个北漂，结果我做到了，哈哈，成为一个合格的北漂，目前已<br>飘了两年多了，以后依然在飘。当达到当时的预期以后，又要思考，相对以后要成为一个什么样的人，一个成功的人？哈哈，其实，自己也没有太多的经历，看到<br>这句话想到的就这些，现在的状态不是太好，但也不坏，别人眼中的我，我也不知道是什么样子，作为个体，一定会和社会发生交流，和陌生人和朋友和同事，做到<br>不在乎被人的看法，目前我是很难做到，但这并不妨碍自己想成为那个想成为的人，利弊只有自己去衡量，所以，不多想，用心做人做事就好。</p>
<h4> “从一个自卑的孩子，到一个传播正面力量的男人，这条路，我走了近三十年的时间。”</h4>

<p>每次看到自卑就会想起高一那段时期，高一那会的自卑来源于成绩和环境，从小县城到市最好的学校，跨度有点大，可能是抻着了，抻了半年多，这可能对我来说，那是适应力还不是很好，高中才开始说普通话，哈哈，想想其实挺可爱，地方上都这样。那会成绩也不好，对老师对同学都不敢说话，相当自卑，现在来看，当时确实是自己不开窍，太注重这些排名，觉得好的排名才可以这样或那样，但是自己又属于悲观中乐观派，怎么感觉就有点精神分裂，其实也不是了，就是偶尔自我安慰自我开导一下，想想爸妈的不容易，就会有不断的动力，我就是那样一个人(这个以后再说)。</p>
<p>好在高二就好了，可能已经适应了环境，发现和自己想象的观点不一样，也就是现在认为的情况，也有自己的好朋友和死党，什么都说，不会有人因为你的成绩看不起你，只会因为你的做人看不起你。记得后来和班里第一名讨论学习，当时怎么想的，一个学渣和学霸在一起讨论学习，现在想想好可爱，后来在北京还和学霸吃过一次饭，学霸依然在上学，依然那么学霸，这就是我们选的的路，或者被选择的路，是路就要走，路很平我们走的很顺，路不平，我们学着改变，时间会磨平我们的菱角，但并不妨碍我们爱自己爱他人，可能注定我们一辈子都过平淡的日子，不会不会像明星一样去传播力量，但是，自己要努力成为你想成为的人，心存善念和感激，照样传播正能量。</p>
<h4> 不如坦诚地接受自己吧，接受有棱有角的我，也接受打磨得平滑的我。因为接受缺陷恰是追求完美的前提。况且，若是我都无法直视完整的自己，又如何以完整的真实的我示人呢？其实，我们是脆弱的，惧怕暴露出的自己得不到别人的肯定。而追根究底，我们是惧怕自己的，惧怕承认自己都无法驾驭的自己，惧怕接受自己都不喜欢的自己。也许我们都理应比想象中强大。</h4>

<p>引自文中12章，这段话很长，有很多的观点在里面，觉得这句话，是非常同意的，由衷的赞同，人无完人，像真理一样伴随我们，自己有时候很喜欢自己，觉得自己<br>很棒，一切事情处理的都很多，有时候又觉得自己怎么会这样，怎么做出这样或那样的事情，想两个人人在打架，一个真实的你一个心里的你。我有时候也会惧怕面对一件<br>不想面对的事情，但终究要面对，各种恐慌迎面而来，这样的事情却是又过，但是最后当你处理好这件事时，又会有释然的感觉，安慰自己，世界上没有过不去的坎，没有跨不过去的河，凡事总是要得到解决的。所以从惧怕到驾驭，这个过程可能很艰辛，但是我觉得自己应该强大自己的内心，想起一句话，忘记了原话是什么，大概意思是：“有时候不是能力不够，而是内心不够强大”，勇敢的去面对自己的，你可以的，加油！！</p>
<h4>“我经常说，我是悲观的乐观主义者。正因为我对未来不作过多假想，机会来的时候我觉得自己是那么的幸运！机会不来的时候，我也觉得理所应当，不会患得患失”</h4>

<p>一直觉得自己挺幸运的，从小到大运气不算太差，也不能说多好，虽然这么说，但是自己仍感谢家人感谢父母，没有他们提供的环境也不会有自己的起点。从小家里还算比较看的开的，爸妈不是那种管的严的人，不过我很乖，也没有叫过一次家长，学习凑活，但爸妈会鼓励我们三个孩子上学，小时候没有太多钱的概念，等后来上班才发现三个孩子的教育费用在那个年代能在里县城买好几套房了，所以更加的感恩父母，爸妈教给我最多的就是做人，学业上的她们也不懂，唯独提供的就是精力和钱，所以让我对家人更有一种特别想关怀的情节在里面，现在会特别宠妹妹，给她买买东西，买我们那个年代想买而没有勇气和钱去买的东西，也许会说，现在小孩都条件好了，不如说我愿意给她买，愿意让她受更好的教育，更健康快乐的成长。为什么觉得自己也有点悲观呢，好多事都是先考虑最坏的情况，各种情况都需要考虑清楚，总之，接受到的讯息总是需要各种考虑，确保不会出差错，也会这样要求妹妹。</p>
<p>机会不来的时候，我也觉得理所应当，不会患得患失，基本上不会相信有什么特别特别好机会降临到我身上，基本上和中五百万彩票似的，从小的教育让我不会去贪小便宜，不要钻漏子，不去闯祸，做一个有责任心的，对待朋友都需要以诚相待，特别是对感情，我承认自己不擅长，会钻牛角尖，会吃醋，不浪漫等等吧，各种无聊的词都会挂在我身上，虽然我知道这种情况或者叫感觉吧，也想努力去改变这种情况，但是战胜一个十几年形成的内心习惯，谈何容易。唯独需要的就是理解，上天眷恋我们让我们相遇，相爱。爱情不是她答应和你在一起就可以了，爱情是长久的，是需要陪伴的，是需要在内心深处时刻想着对方，为对方着想，在爱情这件事情上，我也会悲观着乐观，我在乎的可能你不在乎，你在乎的我必须在乎，这就是我，就在那里，在爱情里，我会倾尽所有付出，这也和从小的教育分不开的，我老是说自己out了，跟不上小鲜肉的思想了，确实我所理解的生活，还是那个从小印象里走过来的生活，对什么事情都很在乎，对她，我是一百个在乎，我不知道她知不知道我的心，可能不被理解，也可能不care，这都无所谓，我相信她会明白的会理解的，自己也不擅长表达，默默的写就好了。最后，自己也会像乐天派那样，往好了想，开导自己。我相信如果她是你要等的那个人，她会懂的并且会越来越爱你，所以我为什么不提前行使在一起的权利。共同迎接我们的未来，好吧就写到这里，写着写着就跑题了，这都不重要，要去找她聊天了！</p>
<p>未完待续–</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://whiskeyfei.github.io/2015/12/28/life/2015-12-28-bye2015hi2016/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="無名">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/face.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="無名小子的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/28/life/2015-12-28-bye2015hi2016/" itemprop="url">无名-我为自己代言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-28T21:55:26+09:00">2015-12-28</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/生活/" itemprop="url" rel="index"><span itemprop="name">生活</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天看到，秋百万发起的 <a href="https://github.com/winter-fall/Bye2015Hi2016" target="_blank" rel="noopener">Bye2015Hi2016</a> ，也来尝试写一篇来记录过去的2015，起个什么名字呢，无名是微信昵称，就《无名-我为自己代言》吧，咱也来说说这一年，早在半年前6月份时候，也写过一篇类似这样的文章，好在列的目标基本上都实现了；</p>
<p>记得当时心情及其糟糕，自身的情况和小伙伴的离职等等吧，自己也很希望赶紧找回工作状态，不知怎么的就看到了 codekk 的 <a href="https://github.com/aosp-exchange-group/fuck-2014-flirt-2015" target="_blank" rel="noopener">fuck-2014-flirt-2015</a> ,看了其他人写的文章，让我触动很大，还有很多的人在奋斗在codeing，不断的受虐同时也在不断的进步，这时候正能量满满的，所以写了下面三个方面：</p>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>说起来还是比较幸运的，毕业就签了某公司的offer，没有犹豫，从实习到正式入职,从旱鸭子到深水区,买了mac，<br>给妈妈买了手机，姐姐妹妹买了衣服鞋子，外甥买了玩具,没给父母丢脸，在北京好好混,从一个没有项目经验的，到第一个、第二个项目，确确实实学到了不少东西。</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>心还是太浮躁，没有沉下心，技术点有些半知半解，浅尝辄止的现象，心情容易受工作影响，很放纵的做一些不想做的事情。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>身体最重要，一定要坚持锻炼，打球游泳不断，阅读书籍（技术非技术都要学习），充实自己，也许在未来就用到了，多回家看看陪陪父母，争取和父母出去玩一次（自己花钱）<br>给妹妹攒钱上大学，稳扎稳打，把技术点一一再过一遍，不会的不清楚的一定要吃透，只有这样才能进步，阅读一些开源框架，不在于多少，在于能够熟练使用,<br>抽空和朋友聚聚，记住出门在外靠朋友，扩展人脉</p>
<p>稀稀拉拉列了不少，现在看着都有些可笑，但是达到上面这样的目标自己也是付出了很多，包括精力时间也包括身体，我一直相信那句话“有付出总会有收获”，自己学的东西没准那一天就用上了，来公司的第一个年基本上都在在加班中度过的，一周6天，偶尔也7天，平常下班到家都11，12点，基本上没有运动，身板不太好的我那会体重只有55KG，然而在14年年末由于阑尾炎直接降到了50KG以下，庆幸慢性阑尾炎没有切掉，也没有和家里说，默默的打点滴一个星期，喝粥吃咸菜，就这样过了年，也完成了版本迭代。</p>
<p>就这样迎来了15年，现在回想起那会的状态，当时自己确实很难受，在租的房间里，一躺就是一天，该坚持该放弃，很明显，我选择了坚持，记住在最无助或者想不开想不懂的时候，别去钻牛角尖，和好兄弟去喝几杯就好了，期间特别爱喝酒，自己回家也会和几罐啤酒，可能自己想麻痹来放松自己，就当减压了吧，这个状态没有持续多久，慢慢也就正常了。</p>
<p>就这样开始去运动，去思考。。学这去改变自己，改变工作状态，改变生活态度。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>按部就班的版本迭代，开发新功能，工作之余，开始使用github，git，开始浏览一些大牛的技术博客，比如：代码家，秋百万，干活集中营，技术小黑屋，胡凯技术博客，codekk等等，开始学习一些框架思想，例如：MVP，MVVP等等，收藏技术贴，学习android性能优化，并能应用到实际项目当中，自己写小demo，使用git提交管理等等，记得第一次给别人PR还有一点的紧张，现在不会了，也fork参与了一些项目，最后说一点这段时间最大的收获吧，技术文章不在于收藏的多少，而在于你自己用心读了多少，不要以为收藏了就学会了，很多时候自己其实在欺骗自己，所以看到一篇想学的技术一定要吃透，应用到自己的实际开发中，这样才能提高。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>开始每周打羽毛球游泳，周末不再有那么多的加班，提高工作效率，平时读了一些小说，google work,重新读了左耳。。青春系列小说，也是够了。。十一时候和小伙伴去青海玩了一趟，感觉很爽，给人一种不一样的感觉，心灵仿佛也得到了洗礼，为那些骑行的人竖起大拇指。下半年刚开始回家看爸妈比较多，给爸妈换上了苹果，当然自己也换了，三件套就差pad了，啧啧，小妹16年高考，作为哥哥也要为妹妹准备点东西，真真切切觉的，温暖的家是你在外工作的后盾，家人身体健康是最大的财富。</p>
<h2 id="展望2016"><a href="#展望2016" class="headerlink" title="展望2016"></a>展望2016</h2><p>1、16年是重要的一年，技术当然要更上一层楼，毕竟靠技术吃饭嘛，还是要稳扎稳打，做好平时的技术积累，知其然知其所以然，多写博客，通过写东西来训练逻辑思维，找几本Android进阶的书，学习RxJava，做读书笔记，避免浅尝辄止，学习框架知识，编写自己的app，应用所学的知识。</p>
<p>2、身体很重要，没了身体＝都没了，所以还是要加强锻炼,健身打球游泳一定要坚持！！</p>
<p>3、找一个城市旅行旅行，这没的说，必须去！！(这个需求再16年开始就完成了，和她一起去的西安，以后还要去更多的地方！)</p>
<p>还是那句话，最重要一点：要好好做人，这个从大学我就一直坚信，做人，要从生活的点点滴滴做起，对家人对朋友一定要真心相待，问心无愧足已。</p>
<p><em>配图为10月份的青海湖，美极了，有机会还要去一次！<em></em></em></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://whiskeyfei.github.io/2015/11/10/android/2016-8-23-android-use-mvp3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="無名">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/face.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="無名小子的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/10/android/2016-8-23-android-use-mvp3/" itemprop="url">Android-architecure MVP 学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-10T19:28:39+09:00">2015-11-10</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MVP 思想已经盛行有一段时间了，之前写过几个简单的 MVP Demo，来分离 UI 和逻辑，前段时间研究了 <a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">googlesamples/android-architecture</a>,这个库包含了好几种 MVP 例子，我针对 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="noopener">todo-mvp </a> 和 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/" target="_blank" rel="noopener">todo-mvp-clean</a><br>这两个例子进行了研究，其他几个例子有不同的侧重，但最基本的还是 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="noopener">todo-mvp </a>，其他只是在这个基础之上做扩充而已，还有一些用到了 Rxjava 的东西，由于项目中没有使用，也就没有详细研究，下面来说说这两个库最基本的用法。</p>
<h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><p>首先要认识到 MVP 是一个思想不是一个框架，不是任何东西都要用它来实现，针对特别简单或者特别复杂的需求或者页面，应根据实际情况来选择，而且要选择使用哪个 MVP 模式作为基本思想。</p>
<h4 id="todo-mvp"><a href="#todo-mvp" class="headerlink" title="todo-mvp"></a>todo-mvp</h4><p>Basic Model-View-Presenter architecture,这个是最基本的 MVP，规定了最基本的 View 和 Presenter，使用者需要继承这两个类，来根据实际情况，增加自己的接口关系，这里的 View 和 Presenter 都在一个类中维护 Contract，在官方 Demo 中，Model<br>数据层的 Repository 在创建 Presenter 的时候就传进来的，而且还是使用的接口，这样也增加了可扩展性，缺点是在调用 M 是一层一层的传递，略显麻烦，不过从代码结构上是清晰的。</p>
<h4 id="todo-mvp-clean"><a href="#todo-mvp-clean" class="headerlink" title="todo-mvp-clean"></a>todo-mvp-clean</h4><p>Based on todo-mvp, uses concepts from Clean Architecture，依靠的还是还是基本的 MVP todo-mvp，只不过在 Model 层做了优化，引入了 Domain Layer 层, Presenter 将不直接调用数据层，而是使用 usecase 方式。</p>
<p>Presenter 要和 Model 打交道，必须通过 Domain 这一层，UseCase 中提供了最基本的请求和回调参数，以及如何调用的抽象方法，每一个子类继承 UseCase 来实现自己的 UseCase，同时<br>又有一个 UseCaseHandler 工具类来管理这些 UseCase 的执行和回调，UseCase 和 UseCaseHandler 都是提供的基类，可以重复利用，对于 case 比较多的案例还是比较适用的。还有这里面<br>有一些线程池的使用，实现类 UseCaseThreadPoolScheduler，来自定义我们的线程调度，包括使用什么队列，线程池大小等。经实际操作验证，一般的页面无需使用这么复杂的结构，如果针对请求情况<br>比较多的 case，可以使用这个。</p>
<p>Model 这一层在 UseCase 中实现，并且和 todo-mvp 一致，数据层的 Repository 在创建 Presenter 时候也要传入到 UseCase 中。</p>
<h4 id="新增-Usecase-方式"><a href="#新增-Usecase-方式" class="headerlink" title="新增 Usecase 方式"></a>新增 Usecase 方式</h4><p>利:<br></p>
<ul>
<li>代码结构清晰，将每个 case 分离互不干扰，而且请求、回调等进行统一化管理，不在过多的依靠外部提供的接口，增加了灵活性；<br></li>
<li>将 view 和逻辑分离，在整合基线明星页过程中，并没有对view层关注，完全屏蔽掉，直进行 Presenter 分发处理，大大增加了效率；<br></li>
<li>Usecase 中有关于线程池的控制以及主线程回调操作；<br></li>
</ul>
<p>弊:<br></p>
<ul>
<li>新增 Usecase 导致代码增多，因为分离的非常细，首先回增加 Usecase 部分的核心代码（这部分可以共用），其次增加了每个具体的 Usecase 类，使得代码整体结构会增加；<br></li>
<li>简单页面不太适合使用 Usecase，建议使用 Base MVP 即可；<br></li>
</ul>
<p>关于参数的封装：</p>
<p>先看代码：</p>
<pre><code>public static class RequestValues implements UseCase.RequestValues {
}

public static class ResponseValue implements UseCase.ResponseValue {

    private final Statistics mStatistics;

    public ResponseValue(@NonNull Statistics statistics) {
        mStatistics = checkNotNull(statistics, &quot;statistics cannot be null!&quot;);
    }

    public Statistics getStatistics() {
        return mStatistics;
    }
}
</code></pre><p>这种方式提供了一种规范，可扩展、统一封装，这样就可以彻底将数据请求相关的屏蔽掉，如果以后更换请求接口，也不会影响到 UseCase 的使用，更不会影响 View 层了。所以比较推荐这种方式。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>public GetStatistics(@NonNull TasksRepository tasksRepository) {
    mTasksRepository = checkNotNull(tasksRepository, &quot;tasksRepository cannot be null!&quot;);
}
</code></pre><p>强烈建议使用 google 的 checkNotNull 这种方式，必须保证不会 null，这个是 Google 的另一库 guava，建议学习下。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://github.com/whiskeyfei/android-architecture-todo-mvp" target="_blank" rel="noopener">https://github.com/whiskeyfei/android-architecture-todo-mvp</a></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="http://rocko.xyz/2015/11/07/MVVM_Android-CleanArchitecture/" target="_blank" rel="noopener">MVVM_Android-CleanArchitecture</a></li>
<li><a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/" target="_blank" rel="noopener">Google android-architecure</a></li>
<li><a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="noopener">android10/Android-CleanArchitecture</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20001838" target="_blank" rel="noopener">android10/Android-CleanArchitecture 中文详解</a></li>
<li><a href="https://github.com/stuartgunter/guava-demo" target="_blank" rel="noopener">guava-demo</a></li>
<li><a href="https://github.com/Syhids/android-architecture/tree/todo-mvp-fragmentless" target="_blank" rel="noopener">todo-mvp-fragmentless</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://whiskeyfei.github.io/2015/11/10/android/2016-3-16-android-memory-tool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="無名">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/face.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="無名小子的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/10/android/2016-3-16-android-memory-tool/" itemprop="url">Android 内存泄漏工具使用分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-10T19:28:39+09:00">2015-11-10</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近的一次事件让我对 Android 开发中内存泄漏重视起来，平时只忙着开发新的功能，往往会忽略掉内存，cpu 等方面的使用情况，然而遇到 内存泄露或者ANR 问题就要彻底解决，由于Android设备规格不一，好一些的设备上不会出现问题，在一些低端的设备上就会出现各种问题，所以平时也要注意内存泄漏和 cpu 使用问题.</p>
<h2 id="内存泄漏-memory-leak"><a href="#内存泄漏-memory-leak" class="headerlink" title="内存泄漏(memory leak)"></a>内存泄漏(memory leak)</h2><p>A memory leak is a particular type of unintentional memory consumption by a computer program where the program fails to release memory when no longer needed. This condition is normally the result of a bug in a program that prevents it from freeing up memory that it no longer needs.This term has the potential to be confusing, since memory is not physically lost from the computer. Rather, memory is allocated to a program, and that program subsequently loses the ability to access it due to program logic flaws.</p>
<p>看不懂 pass。。。知道有这么回事就可以了</p>
<h2 id="初步判断"><a href="#初步判断" class="headerlink" title="初步判断"></a>初步判断</h2><h4 id="现象判断"><a href="#现象判断" class="headerlink" title="现象判断"></a>现象判断</h4><p>从现象入手，如果肉眼能看出页面卡顿，那肯定是有问题的，首先，尝试连续多次打开应用，观察界面卡顿,动画现象，并截取 log，观察 log 中的 GC 输出<br>日志，频繁打印GC日志,说明系统频繁触发GC来释放内存,初步推断可能存在内存泄漏，具体使用 DDMS HEAP 工具分析，以下有介绍</p>
<h4 id="内存命令分析"><a href="#内存命令分析" class="headerlink" title="内存命令分析"></a>内存命令分析</h4><p>前期可以通过一些 ADB 命令来简单查看下内存相关信息，做初步判断，有一次在项目中发现，开启／关闭某个模块，观察内存状态，竟然差了4M，果断修复。</p>
<h4 id="查看内存系统信息"><a href="#查看内存系统信息" class="headerlink" title="查看内存系统信息"></a>查看内存系统信息</h4><pre><code>adb shell cat proc/meminfo

➜  ~ adb shell cat proc/meminfo
MemTotal:        2052484 kB
MemFree:         1450748 kB
Buffers:           23212 kB
Cached:           342548 kB
SwapCached:            0 kB
Active:           338056 kB
Inactive:         203652 kB
Active(anon):     175960 kB
Inactive(anon):     6912 kB
Active(file):     162096 kB
Inactive(file):   196740 kB
..
</code></pre><h4 id="查看某一应用占用内存"><a href="#查看某一应用占用内存" class="headerlink" title="查看某一应用占用内存"></a>查看某一应用占用内存</h4><pre><code>adb shell dumpsys meminfo + packageName
e.g: adb shell dumpsys meminfo com.dangbeimarket

➜  ~ adb shell dumpsys meminfo com.whiskeyfei.tab
Applications Memory Usage (kB):
Uptime: 16199425 Realtime: 16199425

** MEMINFO in pid 14522 [com.whiskeyfei.tab] **
                   Pss  Private  Private  Swapped     Heap     Heap     Heap
                 Total    Dirty    Clean    Dirty     Size    Alloc     Free
                ------   ------   ------   ------   ------   ------   ------
  Native Heap     3474     3356        0        0    15475    15475    13196
  Dalvik Heap     2861     2788        0        0     3156     2561      595
 Dalvik Other      340      328        0        0
        Stack      104      104        0        0
    Other dev        5        0        4        0
     .so mmap     1162      144       48        0
    .apk mmap      220        0       16        0
    .ttf mmap      126        0       16        0
    .dex mmap     2648        0     2644        0
    code mmap     1220        0       88        0
   image mmap     1051      508        8        0
   Other mmap       23        4        0        0
      Unknown       89       88        0        0
        TOTAL    13323     7320     2824        0    18631    18036    13791        
</code></pre><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul>
<li>Native Heap:    C++层内存分配。</li>
<li>Dalvik Heap:    Java层内存分配。</li>
<li>Ashmem :        匿名共享内存。</li>
<li>Stack:        栈区分配的内存。</li>
<li>so mmap:        C库代码占用。</li>
<li>jar mmap ：    Java文件占用。</li>
<li>apk mmap:     apk代码占用。</li>
<li>ttf mmap:     ttf文件占用。</li>
<li>dex mmap:     dex文件代码占用的内存。</li>
<li>Other mmap:    其他文件占用的内存</li>
</ul>
<p>我们要关注 Dalvik Heap 和 Native Heap 占用内存，在使用应用过程中实时查看内存信息状态，来初步判断是否内存使用不当。</p>
<h2 id="DDMS-HEAP-工具"><a href="#DDMS-HEAP-工具" class="headerlink" title="DDMS HEAP 工具"></a>DDMS HEAP 工具</h2><p>Android DDMS 内存监测工具 Heap，可以检测一个进程的内存变化，根据这个数值变化可以测试应用是否存在泄漏。<br>用过debug肯定会用 Heap 了，连接设备启动 app，点 debug 右边的按钮即可（Update Heap 鼠标放上去能看到）</p>
<p><img src="!--￼0--&gt;/mat01.png" alt=""></p>
<p>开始GC，然后就操作 app 观察，Heap视图中部有一个data object，即数据对象，也就是我们的程序中对象<br>正常情况下 Total Size 值都会稳定在一个范围内，反之如果则 data object 的 Total Size 值在每次GC后不会有明显的回落<br>随着操作次数的增多 Total Size 的值会越来越大，就证明可能存在内存泄漏，然后通过其他工具来找出泄漏的地方；</p>
<p><img src="!--￼1--&gt;/mat02.png" alt=""></p>
<h2 id="MAT-Memory-Analyzer-Tool"><a href="#MAT-Memory-Analyzer-Tool" class="headerlink" title="MAT( Memory Analyzer Tool )"></a>MAT( Memory Analyzer Tool )</h2><h3 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h3><p>通过 MAT 分析分析内存中占用比较大的对象   </p>
<p>MAT 是一个内存分析工具，在使用 DEAP 初步判断页面存在内存泄露后，使用 MAT 具体分析出哪写对象没有释放，导致了内存没有释放,关于MAT工具安装，请自行 Google，操作 app，例如：进入某个页面，退出，点击 Dump Hprof file 按钮，等一会会打开MAT视图，没有安装会生成一个文件；</p>
<p><img src="!--￼2--&gt;/mat03.png" alt=""></p>
<p>先观察“Leak suspects”，找出比较大的问题，通过 Dominator Tree 来查看 heap 中比较大的对象，也可以通过 Histogram 查找引用链;<br>Histogram 显示内存中每个对象的数量大小等信息，可以通过关键字来过滤</p>
<p><img src="!--￼3--&gt;/mat04.png" alt=""></p>
<p>例如：搜索 com.main.*;这样就能查找出这些包下面类引用情况，自行右键获得信息，通过提示找出有问题的类或对象，这样就可以找出内存占用多或者泄露的问题了；</p>
<p><img src="!--￼4--&gt;/mat05.png" alt="">  </p>
<p>本例子中查看 Dominator Tree -&gt; 右键某一条 -&gt; Path to GC Roots -&gt; exclude weak references</p>
<p><img src="!--￼5--&gt;/mat06.png" alt=""></p>
<p>Shallow Heap:对象本身的大小<br>Retained Heap:对象本身以及它持有的对象的内存总和</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>通过查看 Histogram 内存中的类以及实例个数</p>
<p>###安装地址</p>
<p><a href="https://eclipse.org/mat/downloads.php" target="_blank" rel="noopener">MAT分析工具</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结了一些常用的工具，用来分析内存问题，以下是注意的步骤</p>
<ul>
<li>使用 ADB 命令初步分析内存</li>
<li>操作应用观察 HEAP update 查看当前内存变化，判断是否存在内存泄露</li>
<li>使用 MAT 来确定哪些代码引起了内存</li>
</ul>
<h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2>  <ul><br>    <li>严格遵守生命周期，创建时创建，销毁时记得回收</li><br>    <li>Bitmip 和 Drawable 记得手动回收</li><br>    <li>静态对象引用 Context，导致对象无法释放，从而导致 Activity 无法释放</li><br>    <li>自定义静态 Handler，Runnable和 Handler 回收</li><br>    <li>使用 Application Context,少使用 Activity Context</li><br>  </ul>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://my.oschina.net/u/2285044/blog/471027#OSC_h3_8" target="_blank" rel="noopener">Android内存泄漏分析实战</a></li>
<li><a href="http://www.cnblogs.com/kissazi2/p/4121852.html" target="_blank" rel="noopener">【译】什么导致了Context泄露：Handler&amp;内部类</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://whiskeyfei.github.io/2015/11/10/android/2015-11-11-android-viewstub/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="無名">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/face.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="無名小子的杂货铺">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/10/android/2015-11-11-android-viewstub/" itemprop="url">Android ViewStub、include、merge 标签使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-10T19:28:39+09:00">2015-11-10</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>总结两个在 Android 局优化中用到的标签，ViewStub 和 include，通过使用这些标签来使布局文件的到重用，嵌到别的布局中，include标签用途：引入重复布局，使布局得到复用。<br>ViewStub：默认不可见，使用时才真正加载，避免创建无用的 view 来消耗系统资源。</p>
<h2 id="1、include-使用"><a href="#1、include-使用" class="headerlink" title="1、include 使用"></a>1、include 使用</h2><pre><code>&lt;include
      android:id=&quot;@+id/top_layout_id&quot;
      android:layout_width=&quot;match_parent&quot;
      android:layout_height=&quot;wrap_content&quot;
      layout=&quot;@layout/title_top_layout&quot; /&gt;

  /**
   * 直接通过this查找，因为include已经转换成layout中的布局
   */
  private void methodTwo() {
      TextView textView = (TextView)findViewById(R.id.textview);
      textView.setText(&quot;Top Title Two&quot;);
  }

  /**
   *  通过mView查找子view控件,mView为layout布局
   */
  private void methodOne() {
      ImageView imageView = (ImageView) mView.findViewById(R.id.imageview);
      TextView textView = (TextView) mView.findViewById(R.id.textview);
      textView.setText(&quot;Top Title One&quot;);
  }
</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>注意标签是是 layout,和 viewStub 区分;</li>
<li>如果 include 设置了 Id 则需要通过 Id 来查找目标布局的根元素;</li>
</ul>
<hr>
<h2 id="二、ViewStub"><a href="#二、ViewStub" class="headerlink" title="二、ViewStub"></a>二、ViewStub</h2><p>ViewStub用途:布局优化，开发中经常听说view优化，但是真正用到得ViewStub可能不多，做下记录，今天优化代码将ViewStub加入,include标签就不用说了,开发经常用的标签，简单的包含父布局；</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>&lt;ViewStub android:id=&quot;@+id/stub&quot;
   android:inflatedId=&quot;@+id/subTree&quot;
   android:layout=&quot;@layout/mySubTree&quot;
   android:layout_width=&quot;120dip&quot;
   android:layout_height=&quot;40dip&quot; /&gt;

ViewStub stub = (ViewStub) findViewById(R.id.stub);
View view = stub.inflate();//这里的view就是include进来的view

//这里的设置了inflatedId则通过inflatedId来获取子view
</code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>延迟加载或者很少几率才用到得view布局，比如:错误信息显示、占位等;</li>
<li>遇到重复的view布局，通过android:layout引入;</li>
<li>存在两者取其一等类似情况，没必要都初始化好;</li>
</ul>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>inflate()被调用之后，返回的是父布局控件对象,不能再次调用inflate();</li>
<li>注意标签是android:layout不是layout,和include区分;</li>
<li>可以使用inflatedId重写ViewStub的父布局控件的Id,也就是说,如果ViewStup设置了inflatedId则需要通过inflatedId来查找目标布局的根元素;</li>
</ul>
<p>ViewStub源码:</p>
<pre><code>public View inflate() {
    final ViewParent viewParent = getParent();

    if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) {
        if (mLayoutResource != 0) {
            final ViewGroup parent = (ViewGroup) viewParent;
            final LayoutInflater factory = LayoutInflater.from(mContext);
            final View view = factory.inflate(mLayoutResource, parent,
                    false);
            //NO_ID＝－1即没有获取到mInflatedId
            if (mInflatedId != NO_ID) {
                view.setId(mInflatedId);
                //如果ViewStub的inflatedId不是NO_ID（－1）则把inflatedId设置为目标布局根元素的id,也就是layout根布局的id
            }

            final int index = parent.indexOfChild(this);
            parent.removeViewInLayout(this);
            final ViewGroup.LayoutParams layoutParams = getLayoutParams();
            if (layoutParams != null) {
                parent.addView(view, index, layoutParams);
            } else {
                parent.addView(view, index);
            }

            mInflatedViewRef = new WeakReference&lt;View&gt;(view);

            if (mInflateListener != null) {
                mInflateListener.onInflate(this, view);
            }

            return view;
        } else {
            throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;);
        }
    } else {
        throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;);
    }
}
</code></pre><h2 id="三、merge"><a href="#三、merge" class="headerlink" title="三、merge"></a>三、merge</h2><p>主要目的是为了减少在 include 布局文件时的层级，例如：如果您的布局中嵌套了两层 LinearLayout ，这时候就存在布局冗余情况，<br>需要使用 merge 标签来减少布局层级，同时还能优化 UI 性能，因为多一层 view 就会多影响渲染性能。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>merge_main.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot; &gt;

    &lt;include
        android:id=&quot;@+id/news_title&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        layout=&quot;@layout/merge_item&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>merge_item.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;

    &lt;Button
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;merge1&quot; /&gt;

    &lt;Button
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;merge2&quot; /&gt;

&lt;/merge&gt;
</code></pre><h3 id="前后对比"><a href="#前后对比" class="headerlink" title="前后对比"></a>前后对比</h3><p>主要是消除 LinearLayout 层级</p>
<p><img src="!--￼0--&gt;/merge1.png" alt="不使用merge"></p>
<p><img src="!--￼1--&gt;/merge2.png" alt="使用merge"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>注意标签是layout,如果使用了 android:layout，则会报错</p>
<pre><code>Exception raised during rendering:
You must specifiy a layout in the include tag: &lt;include layout=&quot;@layout/layoutID&quot; /&gt;
</code></pre><h2 id="四、Demo"><a href="#四、Demo" class="headerlink" title="四、Demo"></a>四、Demo</h2><p>代码是最好的老师，<a href="https://github.com/whiskeyfei/WFAndroidDemo/tree/master/WPLayoutImp" target="_blank" rel="noopener">点我点我</a></p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>官方说明 ViewStub 本质就是一个高度为0个View，默认不可见，只有通过调用setVisibility函数或者Inflate函数才会将其要装载的目标布局给加载出来,从而达到延迟加载效果，不需要的时候也可以不加载</p>
<h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><ul>
<li><a href="http://developer.android.com/intl/zh-cn/reference/android/view/ViewStub.html" target="_blank" rel="noopener">Google ViewStub reference</a></li>
<li><a href="http://blog.csdn.net/hitlion2008/article/details/6737537" target="_blank" rel="noopener">ViewStub的应用</a></li>
<li><a href="http://www.cnblogs.com/menlsh/archive/2013/03/17/2965217.html" target="_blank" rel="noopener">使用惰性控件ViewStub实现布局动态加载</a></li>
<li><a href="http://blog.csdn.net/bboyfeiyu/article/details/45869393#t2" target="_blank" rel="noopener">Android布局优化之ViewStub、include、merge使用与源码分析</a></li>
<li><a href="https://github.com/whiskeyfei/WFAndroidDemo/tree/master/WPLayoutImp" target="_blank" rel="noopener">本文案例</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/face.jpg"
                alt="無名" />
            
              <p class="site-author-name" itemprop="name">無名</p>
              <p class="site-description motion-element" itemprop="description">记录学习、生活</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">47</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">31</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/whiskeyfei" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:whiskeyfei@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/fa272f63280a" target="_blank" title="简书"><i class="fa fa-fw fa-google"></i>简书</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/whiskeyfei" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">無名</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.5</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.5"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.5"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.5"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.5"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.5"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
